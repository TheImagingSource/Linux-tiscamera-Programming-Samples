# Using external trigger and a callback
This sample shows how to capture and process images from an externally triggered camera.
The external trigger signal can be generated by e.g. a light barrier or other sensors. If a camera is triggered externally, a program does not know at which point of time an image will arrive. Polling for an image makes no sense and also may blocks other parts of the program. Therefore, a callback is used. The callback is called, if a new image arrives. In the  callback the image processing is performed. I this sample it is  erosion and saving the resulting image as jpg file.
If a camera is in trigger mode, the automatics of camera properties should be disabled, otherwise unexpected results can happen.

Programming language: Python

## Prerequisites
The sample uses the GStreamer modules from the *tiscamera* repository as wrapper around the
[GStreamer](https://gstreamer.freedesktop.org/) code and property handling. It also uses OpenCV for image processing.

## Files
### TIS.py
In this file the "TIS" class is implemented, which is a wrapper around the GStreamer code. 
### Program.py
This is the main file of the sample.

## The callback
If a camera is triggered, it is always recommended to use a callback function for received images. This avoids a blocking wait for images. The callback function looks like follows:
``` Python
def on_new_image(tis, userdata):
        '''
        Callback function, which will be called by the TIS class
        :param tis: the camera TIS class, that calls this callback
        :param userdata: This is a class with user data, filled by this call.
        '''
        # Avoid being called, while the callback is busy
        if userdata.busy is True:
                return

        userdata.busy = True
        image = tis.get_image()

        # Doing a sample image processing
        kernel = np.ones((5, 5), np.uint8)
        image = cv2.erode(image, kernel, iterations=5) 

        # Create a file name with a running number:
        userdata.imagecounter += 1;
        filename = "./image{:04}.jpg".format(userdata.imagecounter)
        
        # Save the image as jpeg. Instead of saving, there could be an
        # image processing.
        cv2.imwrite(filename, image)
        userdata.busy = False
``` 
The parameters are a reference to the calling TIS class and a class passed to userdata. The user data can be declared as follows:
``` Python
class CustomData:
        ''' Example class for user data passed to the on new image callback function
            It is used for an image counter only. Also for a busy flag, so the callback
            is not called, while a previons callback call is still active.
        '''
        def __init__(self, ):
                self.imagecounter = 0;
                self.busy = False;
``` 


The ```CustomData``` instance is created as:
``` Python
CD = CustomData()
```
The prerequisites for the callback are finished, now the TIS class must get this information. Before we start the live video, the callback is passed to the TIS class:
``` Python
Tis.set_image_callback(on_new_image, CD)
```
## Opening the Camera

``` Python
Tis = TIS.TIS()
# The following line opens and configures the video capture device.
#Tis.openDevice("00001234", 640, 480, "30/1",TIS.SinkFormats.BGRA, True)

# The next line is for selecting a device, video format and frame rate.
if not Tis.select_device():
        quit(0)
``` 
After a device has been opened the live video can be started
``` Python
Tis.start_pipeline()
``` 
The live video is stopped, with
``` Python
Tis.stop_pipeline()
``` 

## Camera properties
Camera automatics should be disabled, while the camera runs in trigger mode. Therefore some properties must be set. This is done with 
``` Python
Tis.set_property(Propertyname, Propertyvalue)
```
A list of properties can be shown by a call to 
``` Python
Tis.list_properties()
```
### Trigger Mode
``` Python
Tis.set_property("Trigger Mode", "Off")  # Use this line for GigE cameras
# Tis.set_property("Trigger Mode", False)  # use this for USB cameras.
```
Unfortunately the Trigger Mode differs between USB and GigE cameras. The line above enables the trigger mode.
Also there is another condition: 
```Tis.start_pipeline()``` does not return, if the Trigger Mode is enabled. Therefore, the Trigger Mode is disabled, then the pipeline is started and the Trigger Mode is enabled again. That is also the reason, why the ```CustomeData.busy``` flag is set to ```True``` before the pipeline is stated. It avoid the callback doing anything, while the trigger is not enabled. 
So the start sequence is:
``` Python
Tis.set_property("Trigger Mode", "Off")
CD.busy = True 
Tis.start_pipeline()
Tis.set_property("Trigger Mode", "On")
# Wait a moment, for the camera accepting trigger mode and also emptyign
# the pipeline
time.sleep(0.1) 
CD.busy = False
```

### White Balance, Exposure and Gain
As mentioned above, the automatics in the camera should be disabled, while the camera is in trigger mode.
``` Python
# In case a color camera is used, the white balance automatic must be
# disabled, because this does not work good in trigger mode
Tis.set_property("Whitebalance Auto", False)
Tis.set_property("Whitebalance Red", 64)
Tis.set_property("Whitebalance Green", 50)
Tis.set_property("Whitebalance Blue", 64)

# Disable gain and exposure automatic
Tis.set_property("Gain Auto", False)
Tis.set_property("Gain",0)
Tis.set_property("Exposure Auto", False)
Tis.set_property("Exposure", 24000)
```

## Mainloop
The main loop waits for keyboard input only.
``` Python
while True:
        key = raw_input("q : quit\nPlease enter:")
        if key == "q":
                break
```






